# 공통 중간 평가 A804

## 노션 링크
[노션으로 이동](https://juvenile-termite-9cf.notion.site/A804-229a8dce873945b4905a47c203d85f04?pvs=4)

## Front-end (박승희, 이현도)

### 사용 기술 스택 및 라이브러리

| Project | Version | Description |
| --- | --- | --- |
| React | 18.2.0 |  |
| react-datepicker | 4.16.0 |  |
| react-daum-postcode | 3.1.3 |  |
| react-infinite-scroll-component | 6.1.0 |  |

### React 구현한 페이지 및 기능

1. 메인 페이지
    
    ![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled.png)
    
    ![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%201.png)
    
    ![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%202.png)
    
2. 소셜 로그인(카카오톡)
    - Kakao Oauth 2.0 활용, 사용자의 인가 코드를 받아 Backend로 전달, Backend에서 로그인/회원가입 여부를 판단하고 user 정보를 받을 예정

![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%203.png)

![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%204.png)

3. 카카오맵 지도 클러스터러 및 필터

- 임시로 작성된 json 파일에서 클러스터러를 생성하여 보여주고 있지만 이후에는 backend에서 전달된 매물 정보를 바탕으로 지도에 생성 예정

![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%205.png)

1. 곰방봐(사진 업로드 커뮤니티)
- 업로드 페이지 (사진 여러장과 해시태그를 리스트 형태로 저장한 후 목록 페이지로 navigate (useNavigate 훅 사용))

![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%206.png)

- 목록 페이지

![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%207.png)

5. 방내놓기 페이지

- 라디오 박스, 체크 박스, 주소 입력 및 위도 경도 추출(Backe, 날짜 입력, 사진 업로드 등

![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%208.png)

![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%209.png)

![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%2010.png)

![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%2011.png)

### 기록용 일일 노션

- [7/31 월요일](https://www.notion.so/7-31-api-ab5d56bc4bc445e09761214c9678afd3?pvs=21)
- [8/1 화요일](https://www.notion.so/8-1-ce83e8fda017466cab96543e1a4e379c?pvs=21)
- [8/2 수요일](https://www.notion.so/8-2-647f4f2b848a44d2a66920484b8a5a92?pvs=21)
- [8/3 목요일](https://www.notion.so/8-3-2fa7ec50de5d4458b2fcf1dbd39e257d?pvs=21)

## (readme아님)커밋 나누기-임시

[https://velog.io/@archivvonjang/Git-Commit-Message-Convention](https://velog.io/@archivvonjang/Git-Commit-Message-Convention)

1. React 기본환경관련 ⇒ index.html, gitignore, package.json, package-lock.json ⇒ 현도

![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%2012.png)

1. assets

![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%2013.png)

![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%2014.png)

1. src/components/maps/ ⇒ 현도
2. src/components/main/ ⇒ 승희
3. src/components/header관련 ⇒ 승희
4. src/pages/login관련 ⇒현도
5. src/pages/mappage관련 ⇒현도
6. src/pages/roomout관련 ⇒ 승희
7. src/pages/gombangba관련 + src/components/gbb관련 ⇒승희
8. src/pages/zimlist ⇒승희

라우터 설정 관련⇒ app.js ⇒승희

글로벌 css ⇒ index.css ⇒승희

## Back-end (박성준, 변지혜, 채희찬, 허태민)

### API 명세서 (백엔드 공통)

### Base Response

```json
{
	"isSuccess": boolean,
	"message": String,
	"code": int,
	"date": T
}
```

[API 명세서](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/API%20%E1%84%86%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A6%E1%84%89%E1%85%A5%201e6cf8c419514aa5a82b21dc8002ee70.csv)

### 박성준

# 프로젝트 활용

## 1. 메인 검색

### **주소**

**********************활용 방법**********************

- 주소에 `OO시`, `OO시 OO구`, `OO시 OO구 OO동`이 포함된 목록 리스트 ⇒ ~~nori_tokenizer~~
    - `match_phrase` 사용 ⇒ 해당 구문이 들어있는 것만 검색 (공백 포함)

**************************Kibana 코드**************************

- 데이터 저장 ⇒ _bulk
    
    ```bash
    PUT rooms_data/_bulk
    {"index":{"_id":1}}
    {"room_id":1, "address":"서울시 강남구 역삼동"}
    {"index":{"_id":2}}
    {"room_id":2, "address":"서울시 광진구 화양동"}
    {"index":{"_id":3}}
    {"room_id":3, "address":"서울시 강남구 논현동"}
    {"index":{"_id":4}}
    {"room_id":4, "address":"경기도 안산시"}
    {"index":{"_id":5}}
    {"room_id":5, "address":"경기도 광주시"}
    {"index":{"_id":6}}
    {"room_id":6, "address":"전라도 순천시 가곡동"}
    {"index":{"_id":7}}
    {"room_id":7, "address":"경상남도 밀양시 가곡동"}
    {"index":{"_id":8}}
    {"room_id":8, "address":"전라도 순천시 가곡동 oo길"}
    {"index":{"_id":9}}
    {"room_id":9, "address":"경기도 안산시 고잔동"}
    {"index":{"_id":10}}
    {"room_id":10, "address":"경기도 안산시 호수동"}
    ```
    

- 데이터 검색
    - `_search` & `matchphrase`
        
        ```bash
        GET rooms_data/_search
        {
          "query":{
            "match_phrase":{
              "address": "경기도 안산시"
            }
          }
        }
        ```
        
    
    - `_search` & `match` & `opreator: and`
        
        ```bash
        GET rooms_data/_search
        {
        	"query": {
        		"match": {
        			"address": {
        			  "query": "경기도 안산시",
                "operator": "and"
        		  }
        		}
        	}
        }
        ```
        

- 결과
    
    ```bash
    {
      "took": 17,
      "timed_out": false,
      "_shards": {
        "total": 1,
        "successful": 1,
        "skipped": 0,
        "failed": 0
      },
      "hits": {
        "total": {
          "value": 3,
          "relation": "eq"
        },
        "max_score": 2.3354583,
        "hits": [
          {
            "_index": "rooms_data",
            "_id": "4",
            "_score": 2.3354583,
            "_source": {
              "room_id": 4,
              "address": "경기도 안산시"
            }
          },
          {
            "_index": "rooms_data",
            "_id": "9",
            "_score": 2.010588,
            "_source": {
              "room_id": 9,
              "address": "경기도 안산시 고잔동"
            }
          },
          {
            "_index": "rooms_data",
            "_id": "10",
            "_score": 2.010588,
            "_source": {
              "room_id": 10,
              "address": "경기도 안산시 호수동"
            }
          }
        ]
      }
    }
    ```
    

**Document**

- 주소
    
    
    | Data | Type | Definition |
    | --- | --- | --- |
    | room_id | int | 방 id |
    | address (지번) | String | 지번 주소 |

************************Spring 성공 코드************************

- ElasticSearchConfig
    
    ```java
    package com.example.elasticsearch.config;
    
    import org.elasticsearch.client.RestHighLevelClient;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.data.elasticsearch.client.ClientConfiguration;
    import org.springframework.data.elasticsearch.client.RestClients;
    import org.springframework.data.elasticsearch.config.AbstractElasticsearchConfiguration;
    import org.springframework.data.elasticsearch.repository.config.EnableElasticsearchRepositories;
    
    @Configuration
    @EnableElasticsearchRepositories
    public class ElasticSearchConfig extends AbstractElasticsearchConfiguration {
        @Override
        public RestHighLevelClient elasticsearchClient() {
            // http port 와 통신할 주소
            ClientConfiguration configuration = ClientConfiguration.builder().connectedTo("localhost:9200").build();
            System.out.println("ee");
            return RestClients.create(configuration).rest();
        }
    }
    ```
    

- RoomSearchDocument ⇒ 매물 Document
    
    ```java
    @Getter
    @NoArgsConstructor
    @Document(indexName = "recStation")
    @Mapping(mappingPath = "json/roomSearch-mapping.json")
    public class RoomSearchDocument {
    
        @Id
        @Field(type = FieldType.Keyword)
        private Integer roomId;
    
        @Field(type = FieldType.Text)
        private String address;
    
        @Field(type = FieldType.Text)
        private String station;
    
        @Field(type = FieldType.Text)
        private String univ;
    
        @GeoPointField
        private Point position;
    
        @Builder
        public RoomSearchDocument(Integer roomId, String address, String station, String univ, Point position) {
            this.roomId = roomId;
            this.address = address;
            this.station = station;
            this.univ = univ;
            this.position = position;
        }
    
        @Override
        public String toString() {
            return "RoomSearchDocument{" +
                    "roomId=" + roomId +
                    ", address='" + address + '\'' +
                    ", station='" + station + '\'' +
                    ", univ='" + univ + '\'' +
                    ", position=" + position +
                    '}';
        }
    }
    ```
    
    - Query로 찾은 값만 리턴 ⇒ 나머지는 `null`로 반환

- roomsearch-mapping.json
    
    ```json
    {
      "properties": {
        "roomId": {"type": "keyword"},
        "address": {"type": "text"},
        "station": {"type": "text"},
        "univ": {"type": "text"},
        "position": {"type": "geo_point"}
      }
    }
    ```
    

- RoomSearchController
    
    ```java
    @RestController
    public class RoomSearchController {
    
        private RoomSearchService roomSearchService = new RoomSearchService();
        private final ElasticsearchOperations elasticsearchOperations;
    
        public RoomSearchController(ElasticsearchOperations elasticsearchOperations) {
            this.elasticsearchOperations = elasticsearchOperations;
        }
    
        @GetMapping("/search/address/{address}")
        public void searchByJiBunAddress(@PathVariable(value = "address") String address) {
            System.out.println("주소 검색");
    
            // match_phrase query 생성
            MatchPhraseQueryBuilder matchPhraseQuery = QueryBuilders.matchPhraseQuery("address", address);
            System.out.println(matchPhraseQuery); // query 확인
    
            // _search query 생성
            NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder();
            queryBuilder.withQuery(matchPhraseQuery); // match_phrase query를 _search 안에 저장
    
            // 결과 출력
            SearchHits<RoomSearchDocument> articles = elasticsearchOperations
                    .search(queryBuilder.build(), RoomSearchDocument.class, IndexCoordinates.of("rooms_data"));
    
            System.out.println(articles); // _search 결과 확인
    
            // 결과 => Document로 매핑
            List<SearchHit<RoomSearchDocument>> searchHitList = articles.getSearchHits();
            ArrayList<RoomSearchDocument> list = new ArrayList<>();
            for (SearchHit<RoomSearchDocument> item : searchHitList) {
                list.add(item.getContent());
            }
    
            // Document 결과 확인
            for (RoomSearchDocument r : list) {
                System.out.println(r.toString());
            }
        }
    
    		/* 역 검색 추가 예정 */
    
    		/* 대학교 검색 추가 예정 */
    }
    ```
    

---

### **역**

******************활용 방법******************

- OO역 근처 Okm 이내에 있는 목록 리스트
    - `geo_point`의 `distance` 사용

****************Document****************

- 역
    
    
    | Data | Type | Definition |
    | --- | --- | --- |
    | room_id | int | 방 id |
    | station | String | 역 이름 |
    | position | Point | 역 위도, 경도 |

**************************Spring 코드**************************

```java
// geo_point query 생성
GeoDistanceQueryBuilder geoDistanceQueryBuilder = QueryBuilders.geoDistanceQuery("location")
        .point(33.33, 127.11)
        .distance(1, DistanceUnit.KILOMETERS);
```

- `GeoDistanceQueryBuilder` 사용

---

### **학교**

**활용 방법**

- OO대학교 근처 Okm 이내에 있는 목록 리스트
    - `geo_point`의 `distance` 사용

**Document**

- 대학교
    
    
    | Data | Type | Definition |
    | --- | --- | --- |
    | room_id | int | 방 id |
    | univ | String | 대학교 이름 |
    | position | Point | 대학교 위도, 경도 |

---

### 통합 Document

| Data | Type | Definition |
| --- | --- | --- |
| room_id | int | 방 id |
| address (지번) | String | 지번 주소 |
| position | Point | 매물 위도, 경도 |
- station
    - 역 이름, 역 위도 **·** 경도가 필요할까?
        
        ⇒ 역 위도 **·** 경도를 넘겨서 계산하면 될 것 같은데
        
    - 위도, 경도로 계산하고 해당 `distance` 범위 내의 `room_id`만 반환하면?
- univ
    - 대학교 이름, 대학교 위도 **·** 경도가 필요할까?
        
        ⇒ 대학교 위도 **·** 경도를 넘겨서 계산하면 될 것 같은데
        
    - 위도, 경도로 계산하고 해당 `distance` 범위 내의 `room_id`만 반환하면?

---

## 2. 매물 등록

### **검색 과정**

1. 주소 입력 (주소 API 활용 - 도로명, 지번, 위도, 경도 데이터 가져옴)
2. 위도 경도 (프론트가 넘겨줌)
3. Elastic Search으로 역까지의 거리 계산
    
    ⇒ `geo_point`의 `distance` 사용 ([Geo - 위치정보](https://www.notion.so/Geo-07b96df060a740469acb160089e76b7a?pvs=21))
    
4. 가까운 역 O개 반환 (내림차순)

### **Document**

| Data | Type | Definition |
| --- | --- | --- |
| room_id | int | 방 id |
| station | String | 역 이름 |
| position | Point | 역 위도, 경도 |

---

## 본문 검색

### **검색 과정**

1. 본문 저장
    
    ⇒ Bulk로 본문 한꺼번에 저장
    
2. Elastic Search로 본문 검색
    
    ⇒ `nori_tokenizer` 사용 ([`분석 과정 이해하기`](https://www.notion.so/d31244f5293146a789d894eb8ebc6bad?pvs=21))
    

| Data | Type | Definition |
| --- | --- | --- |
| room_id | int | 방 id |
| content | String | 본문 |

---

## 참고 사이트

********************************Document, Controller********************************

[Spring Boot로 Elasticsearch 검색하는 API 서버 만들기](https://velog.io/@emily2307/Spring-Boot로-Elasticsearch-검색하는-API-서버-만들기)

[Spring boot + ElasticSearch 연동 하여 실시간 검색 순위 구현하기](https://velog.io/@dktlsk6/Spring-boot-ElasticSearch-연동-하여-실시간-검색-순위-구현하기)

************Search************

[Spring Boot ElasticSearch API 사용하기](https://www.skyer9.pe.kr/wordpress/?p=3573)

******************Geo Point******************

[[Elasticsearch] ElasticsearchOperations로 요청 보내기](https://bgpark.tistory.com/158)

---

# Elastic Search 정리

## Elastic Search 시작하기

### ELK 스택이란

데이터 과학은 깊고 넓은 분야입니다. 분야가 다양하기 때문에 데이터 과학은 각 분야의 팀워크가 생명입니다. 아래는 데이터 과학을 구성하는 각각의 영역을 다이어그램으로 나타낸 그림입니다.

[https://t1.daumcdn.net/cfile/tistory/240B9644594A9E7B2C](https://t1.daumcdn.net/cfile/tistory/240B9644594A9E7B2C)

빅데이터 개발자는 어떤 데이터든 수집하고 빠르게 검색하고 데이터 무더기에서 쓸만한 정보를 보기 좋게 시각화할 수 있어야 합니다. 오픈소스를 이용해 어떤 운영체제를 만나도 운영 가능하도록, 만약 ELK 스택을 마스터한다면, 어떤 빅데이터를 만나도 쉽게 관련 개발을 할 수 있습니다.

[https://t1.daumcdn.net/cfile/tistory/223A7933594AA1E12A](https://t1.daumcdn.net/cfile/tistory/223A7933594AA1E12A)

위 그림은 특정 로그를 수집하고 이를 시각화하는 전체 구조를 도식화 한 것입니다. `Logstash`는 데이터베이스에 무관하게 어떠한 데이터든지 수집해주는 역할을 합니다. `Kibana`는 visualization 툴로 `Elastic Search` 데이터를 보기좋게 화면에 뿌려주는 기능을 합니다.

`Elastic Search`는 키워드가 어떤 Document에 있다고 저장하는 방식입니다. 해쉬 테이블 방식이기 때문에 `BigO 표기법`에 따르면 검색 시, `O(1)`의 효과를 냅니다. 반면 `Relational DB`의 경우, 텍스트 검색 시, 문서 개수만큼 연산이 수행되기 때문에 `O(n)` 갖습니다.

다음은 Elastic Search와 Relational DB를 비교한 표이다.

| Elastic Search | Relational DB |
| --- | --- |
| Index | Database |
| Type | Table |
| Document | Row |
| Field | Column |
| Mapping | Schema |

또한, ElasticSearch를 REST API를 사용하여 관계형 데이터베이스 간 관계를 나타내면 다음과 같다.

| Elastic Search | Relational DB | CRUD |
| --- | --- | --- |
| GET | SELECT | READ |
| PUT | UPDATE | UPDATE |
| POST | INSERT | CREATE |
| DELETE | DELETE | DELETE |

---

### Elastic Search 설치

************************설치 사이트************************

[Download Elasticsearch](https://www.elastic.co/kr/downloads/elasticsearch)

********실행 순서********

1. Platform 선택 - Windows
    
    ![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%2015.png)
    
2. Platform에 따라 파일 다운로드
3. 다운로드 받은 파일 압축 풀기
4. 알맞은 폴더에 넣기 (ex. `C:\elasticsearch\elasticsearch-version`)
5. cmd 창 켜기
    1. Windows 시작 탭 ⇒ cmd 창
    2. Visual Studio Code ⇒ 폴더 열기 ⇒ cmd 창
6. `elasticsearch.bat` 실행
    1. elasticsearch.bat 파일은 `elasticsearch-version\bin 폴더` 안에 존재하기 때문에 bin 폴더로 이동 후 실행
        
        ```bash
        C:\elasticsearch-8.9.0\bin>elasticsearch.bat
        ```
        
    2. `bin 폴더` 안에 들어가지 않고 실행하는 방법
        
        ```
        C:\elasticsearch-8.9.0>.\bin\elasticsearch.bat
        ```
        
7. 실행 확인하기
    1. 실행 중인 상태에서 다른 cmd 창 켜기
    2. 코드 입력
        
        ```json
        C:\elasticsearch-8.9.0>curl -XGET "http://localhost:9200"
        ```
        
    3. 다음과 같은 실행 오류가 발생 ⇒ SSL 설정을 false로 변경
        
        ```json
        curl: (52) Empty reply from server
        ```
        
        - 참고
            
            [오류 모음](https://www.notion.so/2a273f3c616a4da99c8fdc5f270c3162?pvs=21)
            
8. 해당 cmd 창에서 `1. CRUD`부터 따라하기

---

> **참고 - JDK**
현재 Elastic Search에서 배포하는 파일 안에 JDK도 포함해서 배포하기 때문에 따로 설치할 필요 없음
> 

---

### Kibana 설치

************************설치 사이트************************

[Download Kibana Free | Get Started Now](https://www.elastic.co/kr/downloads/kibana)

********실행 순서********

1. Platform 선택 - Windows
    
    ![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%2016.png)
    
2. Platform에 따라 파일 다운로드
3. 다운로드 받은 파일 압축 풀기
4. 알맞은 폴더에 넣기 (ex. `C:\elasticsearch\kibana-version`)
5. cmd 창 켜기
    1. Windows 시작 탭 ⇒ cmd 창
    2. Visual Studio Code ⇒ 폴더 열기 ⇒ cmd 창
6. `kibana` 실행
    1. kibana 파일은 `kibana-version\bin 폴더` 안에 존재하기 때문에 bin 폴더로 이동 후 실행
        
        ```bash
        C:\kibana-8.9.0\bin>kibana
        ```
        
    2. `bin 폴더` 안에 들어가지 않고 실행하는 방법
        
        ```
        C:\kibana-8.9.0>.\bin\kibana
        ```
        
7. `http://localhost:5601`로 들어가서 진행
    
    ![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%2017.png)
    
8. 좌측 목록에 Dev Tools 들어가기
9. Console 창에 이전에 적었던 코드 실행 가능
    1. url은 안적어도 됨
    2. 실행 ⇒ `ctrl + Enter`

---

### 기본 URL 구조

### GET

```bash
curl -XGET "http://localhost:9200/Index/Type/id"
		 -H "Content-Type: application/json"
		 -d Document
```

### POST

```bash
curl -XPOST "http://localhost:9200/Index/Type/id"
		 -H "Content-Type: application/json"
		 -d Document
```

### PUT

```bash
curl -XPUT "http://localhost:9200/Index/Type/id"
		 -H "Content-Type: application/json"
		 -d Document
```

### DELETE

- Index 삭제
    
    ```bash
    curl -XDELETE "http://localhost:9200/Index"
    		 -H "Content-Type: application/json"
    ```
    

- Document 삭제
    
    ```bash
    curl -XDELETE "http://localhost:9200/Index/Type/id"
    		 -H "Content-Type: application/json"
    		 -d Document
    ```
    

---

## 1. CRUD : REST API 를 사용해서 데이터 색인, 조회 및 삭제

### 0. 시작하기

Elastic Search가 설치가 안되어 있다면 설치 후, 아래의 과정을 진행할 것

[Elastic Search 설치](https://www.notion.so/Elastic-Search-e65c3ba073044bc3b1a56756ad045109?pvs=21)

---

### 1. Document 색인

- `PUT "URL"`을 통해 Index, Type 생성
    
    ```bash
    curl -XPUT "http://localhost:9200/my_index/_doc/1"
    		 -H "Content-Type: application/json"
    		 -d "{""message"":""안녕하세요 Elasticsearch""}"
    ```
    
    ```bash
    {"_index":"my_index","_id":"1","_version":1,"result":"created","_shards":{"total":2,"successful":1,"failed":0},"_seq_no":0,"_primary_term":2}
    ```
    
    - `my_index` : Index
    - `_doc` : Type

**********************************************오류가 발생한다면?**********************************************

[오류 모음](https://www.notion.so/2a273f3c616a4da99c8fdc5f270c3162?pvs=21) 

---

### 2. Document 조회

- `GET "URL"`을 통해 Document 조회
    
    ```bash
    curl -XGET "http://localhost:9200/my_index/_doc/1"
    curl -XGET http://localhost:9200/my_index/_doc/1
    ```
    
    ```bash
    {"_index":"my_index","_id":"1","_version":1,"_seq_no":0,"_primary_term":2,"found":true,"_source":{"message":"안녕하세요 Elasticsearch"}}
    ```
    

- 정리해서 출력
    
    ```bash
    curl -XGET "http://localhost:9200/my_index/_doc/1"?pretty
    ```
    
    ```bash
    {
      "_index" : "my_index",
      "_id" : "1",
      "_version" : 1,
      "_seq_no" : 0,
      "_primary_term" : 2,
      "found" : true,
      "_source" : {
        "message" : "안녕하세요 Elasticsearch"
      }
    }
    ```
    

---

### 3. Document 색인 : 기존 Document에 업데이트

- `PUT "URL"`을 통해 업데이트
    
    ```bash
    curl -XPUT "http://localhost:9200/my_index/_doc/1"
    		 -H "Content-Type: application/json"
    		 -d"{""message"":""안녕하세요 Elastic Stack""}"
    ```
    

- 기존의 데이터가 덮어 씌워짐
- Elastic Search는 URL 한 개 당 Document 한 개가 매핑되어 있기 때문에 한번 덮어씌우면 이전 데이터를 찾을 수 없음
    
    ```bash
    {"_index":"my_index","_id":"1","_version":2,"result":"updated","_shards":{"total":2,"successful":1,"failed":0},"_seq_no":1,"_primary_term":2}
    ```
    

---

### 4. Document 색인 : ID 자동 생성

- `POST "URL"`을 통해 Document에 자동으로 ID 생성
    
    ```bash
    curl -XPOST "http://localhost:9200/my_index/_doc"
    		 -H "Content-Type: application/json" 
    		 -d"{""message"":""안녕하세요 Kibana""}"
    ```
    
    ```bash
    {"_index":"my_index","_id":"0v6Sp4kBDgn2YO_Wb2Cl","_version":1,"result":"created","_shards":{"total":2,"successful":1,"failed":0},"_seq_no":2,"_primary_term":2}
    ```
    
    - `"_id":"0v6Sp4kBDgn2YO_Wb2Cl"`를 통해 자동으로 ID가 생성됨을 확인

- `GET "URL+id"`을 통해 조회
    
    ```bash
    curl "http://localhost:9200/my_index/_doc/0v6Sp4kBDgn2YO_Wb2Cl"
    ```
    
    - id가 자동 생성된다고 해서 SQL의 `auto_increment`처럼 숫자가 자동으로 올라가는게 아님

- JSON 파일로 Index에 Document 저장
    
    ```bash
    curl -XPOST "http://localhost:9200/my_index/_doc"
    		 -H "Content-Type: application/json" 
    		 -d @[filename].json
    ```
    

---

### 5. Document 삭제

- `DELETE "URL"`을 통해 삭제
    
    ```bash
    curl -XDELETE "http://localhost:9200/my_index/_doc/1"
    ```
    
    ```bash
    {"_index":"my_index","_id":"1","_version":3,"result":"deleted","_shards":{"total":2,"successful":1,"failed":0},"_seq_no":3,"_primary_term":2}
    ```
    

- 삭제된 Document 조회 시, `"fount" : false`를 통해 찾을 수 없음을 확인
    
    ```bash
    {
      "_index" : "my_index",
      "_id" : "1",
      "found" : false
    }
    ```
    

---

### 6. Index 삭제

- `DELETE "URL"`을 통해 삭제
    
    ```bash
    curl -XDELETE "http://localhost:9200/my_index"
    ```
    
    ```bash
    {"acknowledged":true}
    ```
    

- 삭제된 Index 조회 시, `"type" : "index_not_found_exception"`를 통해 찾을 수 없음을 확인
    
    ```bash
    {
      "error" : {
        "root_cause" : [
          {
            "type" : "index_not_found_exception",
            "reason" : "no such index [my_index]",
            "resource.type" : "index_or_alias",
            "resource.id" : "my_index",
            "index_uuid" : "_na_",
            "index" : "my_index"
          }
        ],
        "type" : "index_not_found_exception",
        "reason" : "no such index [my_index]",
        "resource.type" : "index_or_alias",
        "resource.id" : "my_index",
        "index_uuid" : "_na_",
        "index" : "my_index"
      },
      "status" : 404
    }
    ```
    

---

### 7. 기존 Document에 Field 추가

```bash
curl -XPOST "[url/index/doc/id/_update -d"{"doc" :{[추가할 컬럼]:[값]} }"
```

- 수정도 위와 동일

---

## 2. Bulk 색인

### 0. 시작하기

********Kibana********

- Kibana가 설치가 안되어 있다면 설치 후, 아래의 과정을 진행할 것
    
    [Kibana 설치](https://www.notion.so/Kibana-78695986e2ac43afaa2b6cd3c3d6248b?pvs=21)
    

---

### 1. ********************************************Bluk 색인이란********************************************

다량의 Document를 한꺼번에 색인할 때 사용하는 것

⇒ 반드시 bulk API를 사용

대용량 데이터를 색인할 때는 Bulk를 사용하냐 안하느냐에 따라 속도 차이가 10배 이상이 날 수도 있다.

**bulk를 통해 대용량 데이터 색인**

```bash
POST my_index/_bulk
{"index":{"_id":1}}
{"message":"The quick brown fox"}
{"index":{"_id":2}}
{"message":"The quick brown fox jumps over the lazy dog"}
{"index":{"_id":3}}
{"message":"The quick brown fox jumps over the quick dog"}
{"index":{"_id":4}}
{"message":"Brown fox brown dog"}
{"index":{"_id":5}}
{"message":"Lazy jumping dog"}
```

- 모든 명령이 동일한 인덱스에서 수행되는 경우, 위와 같이 `<인덱스명>/_bulk` 형식으로 사용 가능

- took : 데이터를 색인하는데 얼마나 걸렸는지 (sec)
    
    ```bash
    {
      "took": 10,
      "errors": false,
      "items": [
        {
          "index": {
            "_index": "my_index",
            "_id": "1",
            "_version": 2,
            "result": "updated",
            "_shards": {
              "total": 2,
              "successful": 1,
              "failed": 0
            },
            "_seq_no": 1,
            "_primary_term": 1,
            "status": 200
          }
        },
        ..
      ]
    }
    ```
    

******조회******

```bash
GET my_index/_doc/[_id]
```

---

### 2. JSON 파일로 값 저장

```bash
POST [index] -d @[filename].json
```

---

## 풀텍스트 검색(_search)

### 1. 인덱스의 전체 도큐먼트 검색 : match_all

```bash
GET my_index/_search
{
  "query":{
    "match_all":{ }
  }
}
```

```bash
curl -XGET "[url/index/doc/id/_search]" 
```

********결과********

- 결과 총 개수 : hits ⇒ total ⇒ value
    
    ```bash
    {
      "took": 7,
      "timed_out": false,
      "_shards": {
        "total": 1,
        "successful": 1,
        "skipped": 0,
        "failed": 0
      },
      "hits": {
        "total": {
          "value": 5,
          "relation": "eq"
        },
        "max_score": 1,
        "hits": [
          {
            "_index": "my_index",
            "_id": "1",
            "_score": 1,
            "_source": {
              "message": "The quick brown fox"
            }
          },
          {
            "_index": "my_index",
            "_id": "2",
            "_score": 1,
            "_source": {
              "message": "The quick brown fox jumps over the lazy dog"
            }
          },
          {
            "_index": "my_index",
            "_id": "3",
            "_score": 1,
            "_source": {
              "message": "The quick brown fox jumps over the quick dog"
            }
          },
          {
            "_index": "my_index",
            "_id": "4",
            "_score": 1,
            "_source": {
              "message": "Brown fox brown dog"
            }
          },
          {
            "_index": "my_index",
            "_id": "5",
            "_score": 1,
            "_source": {
              "message": "Lazy jumping dog"
            }
          }
        ]
      }
    }
    ```
    

---

### 2. match 쿼리 : dog 검색

- 특정 단어가 포함된 Document 검색
    
    ```bash
    GET my_index/_search
    {
      "query": {
        "match": {
          "message": "dog"
        }
      }
    }
    ```
    
    ```bash
    curl -XGET "[url/index/doc/id/_search?q=[col]:[value]]"
    curl -XGET "[url/index/doc/id/_search?q=[col]:[value]]&pretty"
    ```
    

---

### 3. match 쿼리 : quick 또는 dog 검색 (or)

- 공백을 기준으로 여러개의 메시지를 넣을 경우, OR 조건으로 인식
    
    ⇒ a 또는 b가 있는 모든 결과를 반환
    
    ```bash
    GET my_index/_search
    {
      "query": {
        "match": {
          "message": "quick dog"
        }
      }
    }
    ```
    

---

### 4. match 쿼리 : quick 과 dog 검색 (and)

- message 안에 query를 추가하여 검색
- operator를 and로 설정하여 검색
    
    ```bash
    GET my_index/_search
    {
      "query": {
        "match": {
          "message": {
            "query": "quick dog",
            "operator": "and"
          }
        }
      }
    }
    ```
    

---

### 5. match_phrase 쿼리 : "lazy dog" 구문 검색

- 구문에 모든 구문이 있는 결과를 반환
    
    ⇒ 정확히 구문이 있어야 함 (space 포함)
    
    ```bash
    GET my_index/_search
    {
      "query": {
        "match_phrase": {
          "message": "lazy dog"
        }
      }
    }
    ```
    

---

## 4. 복합 쿼리

### 0. 시작하기

- bool 쿼리를 이용한 서브쿼리 조합
    
    ```bash
    {
    	"query": {
    		"bool": {
    			구문 작성
    		}
    	},
    }
    ```
    

- 종류
    - must : 쿼리가 참인 Document를 검색
    - must_not : 쿼리가 거짓인 Document를 검색
    - should : 검색 결과 중 이 쿼리에 해당하는 Document의 점수를 높임
        
        ⇒ 스코어 향상 ⇒ 정확도 향상
        
    - filter : 쿼리가 참인 Document를 검색하지만 스코어를 계산하지 않음. must 보다 검색 속도가 빠르고 캐싱됨

---

### 1. "quick" 와 "lazy dog" 가 포함된 모든 문서 검색

- `must` 조건을 통해 반드시 있어야 하는 단어 or 구문 확인
    
    ```bash
    GET my_index/_search
    {
      "query": {
        "bool": {
          "must": [
            {
              "match": { "message": "quick" }
            },
            {
              "match_phrase": { "message": "lazy dog" }
            }
          ]
        }
      }
    }
    ```
    

---

### 2. "fox" 를 포함하는 모든 도큐먼트 중 "lazy" 가 포함된 결과에 가중치 부여

- `should` 조건을 통해 특정 메시지가 들어있는 값의 `score`를 높임
    
    ```bash
    GET my_index/_search
    {
      "query": {
        "bool": {
          "must": [
            {
              "match": {
                "message": "fox"
              }
            }
          ],
          "should": [
            {
              "match": {
                "message": "lazy"
              }
            }
          ]
        }
      }
    }
    ```
    

---

### 3. "fox" 와 "quick" 을 포함하는 쿼리의 must & filter 스코어 비교

- `filter` 조건을 통해 쿼리가 참인 Document를 검색
    
    ⇒ `score` 계산 X
    
- `must`보다 검색 속도가 빠르고 캐싱됨
    
    ```bash
    GET my_index/_search
    {
      "query": {
        "match": {
          "message": "fox"
        }
      }
    }
    ```
    
    ```bash
    GET my_index/_search
    {
      "query": {
        "bool": {
          "must": [
            {
              "match": {
                "message": "fox"
              }
            },
            {
              "match": {
                "message": "quick"
              }
            }
          ]
        }
      }
    }
    ```
    
    ```bash
    GET my_index/_search
    {
      "query": {
        "bool": {
          "must": [
            {
              "match": {
                "message": "fox"
              }
            }
          ],
          "filter": [
            {
              "match": {
                "message": "quick"
              }
            }
          ]
        }
      }
    }
    ```
    

---

## 5. Range 쿼리

### 0. 시작하기

- gte (Greater-than or equal to) : 이상 (같거나 큼)
- gt (Greater-than) : 초과 (큼)
- lte (Less-than or equal to) : 이하 (같거나 작음)
- lt (Less-than) : 미만 (작음)

**********테스트 코드 - bulk**********

```bash
POST phones/_bulk
{"index":{"_id":1}}
{"model":"Samsung GalaxyS 5","price":475,"date":"2014-02-24"}
{"index":{"_id":2}}
{"model":"Samsung GalaxyS 6","price":795,"date":"2015-03-15"}
{"index":{"_id":3}}
{"model":"Samsung GalaxyS 7","price":859,"date":"2016-02-21"}
{"index":{"_id":4}}
{"model":"Samsung GalaxyS 8","price":959,"date":"2017-03-29"}
{"index":{"_id":5}}
{"model":"Samsung GalaxyS 9","price":1059,"date":"2018-02-25"}
```

---

### 1. price 필드 값이 700 이상, 900 미만인 데이터를 검색

- 특정 필드 값의 범위 내의 값을 검색
    
    ```bash
    GET phones/_search
    {
      "query": {
        "range": {
          "price": {
            "gte": 700,
            "lt": 900
          }
        }
      }
    }
    ```
    

---

### 2. date필드의 날짜가 2016년 1월 1일 이후인 Document 검색

- 날짜 검색 ⇒ date 형식 맞춰서 검색
    
    ```bash
    GET phones/_search
    {
      "query": {
        "range": {
          "date": {
            "gt": "2016-01-01"
          }
        }
      }
    }
    ```
    

---

### 3. date필드의 날짜가 오늘부터 2년 전 이후인 Document 검색

```bash
GET phones/_search
{
  "query": {
    "range": {
      "date": {
        "gt": "now-2y"
      }
    }
  }
}
```

---

## 6. 텍스트 분석 - Analyser

### 0. 시작하기

************************색인 과정************************

Elastic Search는 데이터를 색인될 때, 검색에 필요한 형태로 분리됨

분리되는 과정을 `Analysis`라고 함 (텍스트 분석)

문장을 분리하는 도구를 `Analyzer`라고 함

`Analyzer`는 하나의 Tokenizer와 여러 개의 Token Filter로 구성

********************************************공식 문서 가이드********************************************

[Tokenizer reference | Elasticsearch Guide [8.9] | Elastic](https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-tokenizers.html)

---

### 1. Tokenizer 을 통해 문장을 검색어 텀(term)으로 쪼갬

```bash
GET my_index/_analyze
{
	"tokenizer": "standard",
	"text": "Brown fox brown dog"
}
```

- Standard : 기본 Analyzer
    
    ⇒ 공백 기준으로 분리
    

```bash
{
  "tokens": [
    {
      "token": "Brown",
      "start_offset": 0,
      "end_offset": 5,
      "type": "<ALPHANUM>",
      "position": 0
    },
    {
      "token": "fox",
      "start_offset": 6,
      "end_offset": 9,
      "type": "<ALPHANUM>",
      "position": 1
    },
		...
  ]
}
```

- start_offset : 시작 위치
- end_offset : 종료 위치
- type : 타입
- position : 순서

---

### 2. Filter(토큰필터) 를 통해 쪼개진 텀들을 가공

- 2-1. lowercase - 소문자로 가공
    
    ```bash
    GET my_index/_analyze
    {
    "tokenizer": "standard",
    	"filter": [
    		"lowercase"
    	],
    	"text": "Brown fox brown dog"
    }
    ```
    

- 2-2. unique - 중복 텀 제거
    
    ```bash
    GET my_index/_analyze
    {
    	"tokenizer": "standard",
    	"filter": [
    		"lowercase",
    		"unique"
    	],
    	"text": "Brown brown brown fox brown dog"
    }
    ```
    

---

### 3. (Tokenizer + Filter) 대신 Analyzer 사용

```bash
GET my_index/_analyze
{
	"analyzer": "standard",
	"text": "Brown fox brown dog"
}
```

---

## 7. 분석 과정 이해하기

### 1. 복합적인 문장 분석 - T:standard, F:lowercase

```bash
GET my_index/_analyze
{
  "tokenizer": "standard",
  "filter": [
    "lowercase"
  ],
  "text": "THE quick.brown_FOx jumped! $19.95 @ 3.0"
}
```

- standard
    - 중간에 껴있는 부호는 지우지 않음 (`.`, `_` 포함)
    - 양 끝의 부호를 지움 ⇒ 공백으로 잘랐을 때의 양쪽 부호

---

### 2. 복합적인 문장 분석 - T:letter, F:lowercase

```bash
GET my_index/_analyze
{
  "tokenizer": "letter",
  "filter": [
    "lowercase"
  ],
  "text": "THE quick.brown_FOx jumped! $19.95 @ 3.0"
}
```

- letter : 알파벳이 아닌 모든 것을 구분자로 인식

---

### 3. Email, URL 분석 - T:standard

```bash
GET my_index/_analyze
{
  "tokenizer": "standard",
  "text": "elastic@example.com website: https://www.elastic.co"
}
```

- standard를 통해 email 분석

---

### 4. Email, URL 분석 - T:uax_url_email

```bash
GET my_index/_analyze
{
  "tokenizer": "uax_url_email",
  "text": "elastic@example.com website: https://www.elastic.co"
}
```

- uax_url_email : 이메일 형식과 url 형식은 남겨둔 채로 분리

---

### 5. 한글 분석

**한글 형태소 분석기 nori 설치**

```bash
$ bin/elasticsearch-plugin install analysis-nori
```

- standard 분석과는 다르게 한글 사전을 기반으로 형태소까지 분리해서 색인
    - ex) `날씨가 ⇒ [날씨, 가]`

**기본 standard 분석**

```bash
GET _analyze
{
  "tokenizer": "standard",
  "text": ["동해물과 백두산이"]
}
```

```bash
{
  "tokens": [
    {
      "token": "동해물과",
      "start_offset": 0,
      "end_offset": 4,
      "type": "<HANGUL>",
      "position": 0
    },
    {
      "token": "백두산이",
      "start_offset": 5,
      "end_offset": 9,
      "type": "<HANGUL>",
      "position": 1
    }
  ]
}
```

`**nori_tokenizer`를 이용한 한글 분석**

```bash
{
  "tokens": [
    {
      "token": "동해",
      "start_offset": 0,
      "end_offset": 2,
      "type": "word",
      "position": 0
    },
    {
      "token": "물",
      "start_offset": 2,
      "end_offset": 3,
      "type": "word",
      "position": 1
    },
    {
      "token": "과",
      "start_offset": 3,
      "end_offset": 4,
      "type": "word",
      "position": 2
    },
    {
      "token": "백두",
      "start_offset": 5,
      "end_offset": 7,
      "type": "word",
      "position": 3
    },
    {
      "token": "산",
      "start_offset": 7,
      "end_offset": 8,
      "type": "word",
      "position": 4
    },
    {
      "token": "이",
      "start_offset": 8,
      "end_offset": 9,
      "type": "word",
      "position": 5
    }
  ]
}
```

- 한글 사전을 기준으로 분류 (공백 기준 X)

**추가 자료**

[Elasticsearch를 검색 엔진으로 사용하기(1): Nori 한글 형태소 분석기로 검색 고도화 하기 - 하나몬](https://hanamon.kr/elasticsearch-검색엔진-nori-형태소-분석기-검색-고도화-방법/)

---

## 8. 인덱스 생성

### 0. 시작하기

- settings : analyzer, 샤드 수, 리프레시 주기 등을 설정
- mappings : 각 필드별 데이터 명세를 정의
    - settings, mappings 는 대부분 변경 불가

---

### 1. 사용자 정의 analyzer

```bash
PUT my_index_2
{
  "settings": {
    "analysis": {
      "analyzer": {
        "my_analyzer": {
          "tokenizer": "letter",
          "filter": [
            "lowercase",
            "stop"
          ]
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "message": {
        "type": "text",
        "analyzer": "my_analyzer"
      }
    }
  }
}
```

- 사용자 정의 my_analyzer 생성 후, 등록
- `filter : stop` :불용어를 제거하는 역할
    - ex) a, an, and, are ,the, then, …
- my_analyzer를 analyzer에 등록

---

### 2. 사용자 정의 analyzer 필드에 데이터 색인

```bash
PUT my_index_2/_doc/1
{
  "message": "THE quick.brown_FOx jumped! $19.95 @ 3.0"
}
```

- 1번에서 `letter Tokenizer`를 사용했기 때문에 알파벳으로 분리 (quick, brown, fox 등)

---

### 3. 데이터 검색

```bash
GET my_index_2/_search
{
  "query": {
    "match": {
      "message": "brown"
    }
  }
}
```

- brown이 포함된 것 검색

```bash
GET my_index_2/_search
{
  "query": {
    "match": {
      "message": "the"
    }
  }
}
```

- `filter : stop`으로 불용어를 제거했기 때문에 검색되지 않음

---

## 9. Aggregation - 집계

### 0. 시작하기

******용어******

- metrics : min, max, sum, avg 등의 계산
- bucket : 특정 기준으로 Document들을 그룹화

**********************테스트 코드**********************

```bash
PUT my_stations/_bulk
{"index": {"_id": "1"}}
{"date": "2019-06-01", "line": "1호선", "station": "종각", "passengers": 2314}
{"index": {"_id": "2"}}
{"date": "2019-06-01", "line": "2호선", "station": "강남", "passengers": 5412}
{"index": {"_id": "3"}}
{"date": "2019-07-10", "line": "2호선", "station": "강남", "passengers": 6221}
{"index": {"_id": "4"}}
{"date": "2019-07-15", "line": "2호선", "station": "강남", "passengers": 6478}
{"index": {"_id": "5"}}
{"date": "2019-08-07", "line": "2호선", "station": "강남", "passengers": 5821}
{"index": {"_id": "6"}}
{"date": "2019-08-18", "line": "2호선", "station": "강남", "passengers": 5724}
{"index": {"_id": "7"}}
{"date": "2019-09-02", "line": "2호선", "station": "신촌", "passengers": 3912}
{"index": {"_id": "8"}}
{"date": "2019-09-11", "line": "3호선", "station": "양재", "passengers": 4121}
{"index": {"_id": "9"}}
{"date": "2019-09-20", "line": "3호선", "station": "홍제", "passengers": 1021}
{"index": {"_id": "10"}}
{"date": "2019-10-01", "line": "3호선", "station": "불광", "passengers": 971}
```

### 1. 전체 passengers 필드 값의 합계를 가져오는 metrics aggregation

```bash
GET my_stations/_search
{
  "size": 0,
  "aggs": {
    "all_passengers": {
      "sum": {
        "field": "passengers"
      }
    }
  }
}
```

```bash
curl -XGET [url/_search?pretty --data-binary @[filename] // json 파일
```

- size : 출력할 데이터 개수
- aggregation : aggs 또는 aggregations 입력
- `all_passengers` : 임의의 이름

```bash
{
  "took": 3,
  "timed_out": false,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped": 0,
    "failed": 0
  },
  "hits": {
    "total": {
      "value": 10,
      "relation": "eq"
    },
    "max_score": null,
    "hits": []
  },
  "aggregations": {
    "all_passangers": {
      "value": 41995
    }
  }
}
```

- `total : value` : 계산한 데이터 개수

### 2. "station": "강남" 인 도큐먼트의 passengers 필드값의 합계를 가져오는 metrics aggregation

```bash
GET my_stations/_search
{
  "query": {
    "match": {
      "station": "강남"
    }
  },
  "size": 0,
  "aggs": {
    "gangnam_passengers": {
      "sum": {
        "field": "passengers"
      }
    }
  }
}
```

- match를 통해 특정값이 있는 Document를 가져옴

### 3. date_histogram으로 date 필드를 1개월 간격으로 구분하는 bucket aggregation

```bash
GET my_stations/_search
{
  "size": 0,
  "aggs": {
    "date_his": {
      "date_histogram": {
        "field": "date",
        "interval": "month"
      }
    }
  }
}
```

### 4. stations.keyword 필드 별로 passengers 필드의 평균값을 계산하는 bucket & metrics aggregation

```bash
GET my_stations/_search
{
  "size": 0,
  "aggs": {
    "stations": {
      "terms": {
        "field": "station.keyword"
      },
			"aggs": {
        "avg_psg_per_st": {
          "avg": {
            "field": "passengers"
          }
        }
      }
    }
  }
}
```

- `terms : [field]` : 특정 keyword 별로 나눔
    - 같은 keyword 끼리 묶어서 계산
    - ex) `my_stations` ⇒ `station` 필드의 값 별로 나눔

### 5. 모든 Aggregation 출력

```bash
curl -XGET [url/_search?pretty --data-binary @[json] // json 파일
```

- JSON 파일 코드
    
    ```bash
    {
    	"size": 0,
    	"aggs": {
    		"stats_score":{
    			"stats": {
    				"field": [columne name]
    			}
    		}
    	}
    }
    ```
    

---

## 10. Geo - 위치 정보

### 0. 시작하기

**geo_point 타입의 location 필드 선언**

```bash
PUT my_geo
{
  "mappings": {
    "properties": {
      "location": {
        "type": "geo_point"
      }
    }
  }
}
```

- geo_point를 type으로 선언해야 실수 타입이 아닌 { lat, lon }처럼 단일 Field로 들어감

**예제 데이터 입력**

```bash
PUT my_geo/_bulk
{"index": {"_id": "1"}}
{"station": "강남", "location": {"lon":127.027926, "lat":37.497175 }, "line": "2호선"}
{"index": {"_id": "2"}}
{"station": "종로3가", "location": {"lon":126.991806, "lat":37.571607}, "line": "3호선"}
{"index": {"_id": "3"}}
{"station": "여의도", "location": {"lon":126.924191, "lat":37.521624}, "line": "5호선"}
{"index": {"_id": "4"}}
{"station": "서울역", "location": {"lon":126.972559, "lat":37.554648}, "line": "1호선"}

```

- `geo_point : { "lat": 41.12, "lon": -71.34 }` 같은 형식으로 입력

### 1. geo_bounding_box : 두 점을 기준으로 하는 네모 안에 있는 도큐먼트들을 가져옴

```bash
GET my_geo/_search
{
  "query": {
    "geo_bounding_box": {
      "location": {
        "bottom_right": {
          "lat": 37.4899,
          "lon": 127.0388
        },
        "top_left": {
          "lat": 37.5779,
          "lon": 126.9617
        }
      }
    }
  }
}
```

- `geo_bounding_box` : 지도에 사각형을 그려서 해당 범위 안에 있는 Document를 가져옴

### 2. geo_distance : 한 점을 기준으로 반경 안에 있는 도큐먼트들을 가져옴

```bash
GET my_geo/_search
{
  "query": {
    "geo_distance": {
      "distance": "5km",
      "location": {
        "lat": 37.5358,
        "lon": 126.9559
      }
    }
  }
}
```

- `geo_distance` : 반경 0km 이내의 Document를 가져옴

---

# 오류 모음

## SSL 인증서 오류

다음과 같은 오류가 발생하는 경우, SSL 인증서 문제이다

```bash
curl: (52) Empty reply from server
```

해당 에러는 접속할 때 HTTP를 사용해서 발생하는 에러다.

버전 8부터 SSL/TLS가 기본적으로 설정되어 있기 때문이다.

해결 방법은 `\elasticsearch-8.9.0\config\elasticsearch.yml`의 SSL 설정을 `true`에서 `false`로 수정해야 한다.

```yaml
# Enable security features
xpack.security.enabled: false

xpack.security.enrollment.enabled: false

# Enable encryption for HTTP API client connections, such as Kibana, Logstash, and Agents
xpack.security.http.ssl:
  enabled: false
  keystore.path: certs/http.p12

# Enable encryption and mutual authentication between cluster nodes
xpack.security.transport.ssl:
  enabled: false
  verification_mode: certificate
  keystore.path: certs/transport.p12
  truststore.path: certs/transport.p12
# Create a new cluster with the current node only
# Additional nodes can still join the cluster later
cluster.initial_master_nodes: ["USER"]
```

### 참고 사이트

[curl: (52) Empty reply from server #ElasticSearch 8.3.3](https://nanglam.tistory.com/33)

---

## 따옴표, 브라켓 오류

다음과 같이 입력했을 때, 오류가 발생하는 경우, 문법 오류이다.

```bash
curl -XPUT http://localhost:9200/my_index/_doc/1 -H "Content-Type: application/json" -d {"message":"안녕하세요 Elasticsearch"}
```

```bash
curl: (3) unmatched brace in URL position 1: {"message":"안녕하세요 Elasticsearch"...
```

문법을 확인하자.

- `'http -> "http`와 같이 큰따옴표를 붙여야 함
- `"{""message"":""안녕하세요 Elasticsearch""}"`와 같이 묶어줘야 함
    
    ```bash
    curl -XPUT "http://localhost:9200/my_index/_doc/1" -H "Content-Type: application/json" -d "{""message"":""안녕하세요 Elasticsearch""}"
    ```
    

- 추후 Kibana를 사용하면 `url`을 작성하지 않고 사용할 수 있기 때문에 커맨드 창으로 `Elastic Search`를 사용할 때 유의하자

### **참고 사이트**

[window10+elasticsearch sample 실행 시 오류 curl: (1) Protocol "'http" not supported or disabled in libcurl](https://badangel1004.tistory.com/39)

### 변지혜

## 카카오 로그인 기능 구현

### 참고 사이트

[Kakao Developers](https://developers.kakao.com/docs/latest/ko/kakaologin/common)

[Kakao Developers](https://developers.kakao.com/docs/latest/ko/kakaologin/rest-api)

[[Spring Boot]카카오 로그인 구현](https://shxrecord.tistory.com/290)

[WebClient를 이용한 소셜 로그인 구현](https://velog.io/@rnqhstlr2297/Spring-Security와-JWT를-이용한-Social-Login-구현)

[Oauth 카카오 로그인 + Spring Boot + JWT 로그인 구현(1)](https://dobi852.tistory.com/35)

### 서비스 로그인 과정

![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%2018.png)

![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%2019.png)

![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%2020.png)

### 카카오 로그인 요청 URL

```java
https://kauth.kakao.com/oauth/authorize?response_type=code&client_id=${REST_API_KEY}&redirect_uri=${REDIRECT_URI}

https://kauth.kakao.com/oauth/authorize?response_type=code&client_id=a20ef37212e1ae86b20e09630f6590ce&redirect_uri=http://localhost:8080/member/login
```

### application.properties에 추가

```java
# 카카오 로그인 설정
kakao.client.id=a20ef37212e1ae86b20e09630f6590ce
kakao.client.secret=########################
kakao.redirect.url=http://localhost:8080/member/login
```

### com.ssafy.member.domain.Member

```java
package com.ssafy.member.domain;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import javax.persistence.*;
import javax.validation.constraints.NotNull;
import java.util.UUID;

@Builder
@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Member {

    @Id
    @Column(name ="member_id", columnDefinition = "BINARY(16)")
    private UUID id;

    @Builder.Default
    @NotNull
    private String name = "사용자";

    @NotNull
    private String channelId;

    @NotNull
    private String nickname;

    @NotNull
    private String email;

    @NotNull
    @Enumerated(EnumType.ORDINAL)
    private Gender gender;

}
```

### com.ssafy.member.domain.Gender

```java
package com.ssafy.member.domain;

public enum Gender {
    MALE, FEMALE, NULL;

}
```

### com.ssafy.member.dto.KakaoTokenResponseDto

```java
package com.ssafy.member.dto;

import lombok.Getter;
import lombok.NoArgsConstructor;

@Getter
@NoArgsConstructor
public class KakaoTokenResponseDto {

    private String access_token;

}
```

### com.ssafy.member.dto.KakaoLoginResponseDto

```java
package com.ssafy.member.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.ToString;

import javax.validation.constraints.NotNull;

@Getter
@NoArgsConstructor
public class KakaoLoginResponseDto {

    private String id;

    private KakaoAccount kakao_account;

    @Getter
    @NoArgsConstructor
    public class KakaoAccount {

        private String email;

        private String gender;

    }

}
```

### com.ssafy.member.dto.MemberLoginResponseDto

```java
package com.ssafy.member.dto;

import com.ssafy.member.domain.Member;
import lombok.*;

import javax.validation.constraints.NotNull;

@NoArgsConstructor
@AllArgsConstructor
public class MemberLoginResponseDto {

    @NotNull
    private Member member;
}
```

### com.ssafy.member.dto.MemberUpdateRequestDto

```java
package com.ssafy.member.dto;

import com.ssafy.member.domain.Member;
import lombok.*;

import javax.validation.constraints.NotNull;

@Getter
@NoArgsConstructor
@AllArgsConstructor
public class MemberUpdateRequestDto {

    @NotNull
    private Member member;
}
```

### com.ssafy.member.repository.MemberRepository

```java
package com.ssafy.member.repository;

import com.ssafy.member.domain.Member;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;

@Repository
public interface MemberRepository extends JpaRepository<Member, UUID> {

    Optional<Member> findByChannelId(String channelId);

    Optional<Member> findById(UUID id);

}
```

### com.ssafy.member.service.MemberService

WebClient를 사용해 API 호출

```java
package com.ssafy.member.service;

import com.ssafy.member.domain.Gender;
import com.ssafy.member.domain.Member;
import com.ssafy.member.dto.KakaoLoginResponseDto;
import com.ssafy.member.dto.KakaoTokenResponseDto;
import com.ssafy.member.dto.MemberUpdateRequestDto;
import com.ssafy.member.repository.MemberRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.reactive.function.client.WebClient;

import javax.transaction.Transactional;
import java.util.NoSuchElementException;
import java.util.UUID;

@Service
@RequiredArgsConstructor
public class MemberService {

    private final MemberRepository memberRepository;

    @Value("${kakao.client.id}")
    private String KAKAO_CLIENT_ID;

    @Value("${kakao.client.secret}")
    private String KAKAO_CLIENT_SECRET;

    @Value("${kakao.redirect.url}")
    private String KAKAO_REDIRECT_URL;

    private final static String KAKAO_AUTH_URI = "https://kauth.kakao.com/oauth/token";
    private final static String KAKAO_API_URI = "https://kapi.kakao.com/v2/user/me";

    // 카카오 인가코드로 토큰 발급 요청
    public KakaoTokenResponseDto getKaKaoToken(String code) {
        // 인가코드가 있는지 확인
        if (code == null)
//            throw new Exception("Failed get authorization code");
            System.out.println("코드없음");

        // 카카오로 보낼 바디 만들기
        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
        params.add("grant_type", "authorization_code");
        params.add("client_id", KAKAO_CLIENT_ID);
        params.add("client_secret", KAKAO_CLIENT_SECRET);
        params.add("redirect_uri", KAKAO_REDIRECT_URL);
        params.add("code", code);

        // API 호출
        // POST방식으로 카카오에 요청 보내기
        KakaoTokenResponseDto kakaoTokenResponseDto = WebClient.create()
                .post()
                .uri(KAKAO_AUTH_URI)
                .header("Content-type","application/x-www-form-urlencoded;charset=utf-8" )
                .bodyValue(params)
                .retrieve()
                .bodyToMono(KakaoTokenResponseDto.class)
                .block();

        // 토큰 반환
        return kakaoTokenResponseDto;
    }

    // 토큰으로 카카오 사용자 정보 요청
    public KakaoLoginResponseDto getMemberInfoWithToken(KakaoTokenResponseDto kakaoTokenResponseDto) {
        // API 호출
        // POST방식으로 카카오에 요청 보내기
        KakaoLoginResponseDto kakaoLoginResponseDto = WebClient.create()
                .post()
                .uri(KAKAO_API_URI)
                .headers(header -> header.setBearerAuth(kakaoTokenResponseDto.getAccess_token()))
                .retrieve()
                .bodyToMono(KakaoLoginResponseDto.class)
                .block();

        // channelId, email, gender 데이터 반환
        return kakaoLoginResponseDto;
    }

    // 들어온 사용자 정보 + 생성한 UUID/닉네임으로 회원가입 (DB에 저장)
    @Transactional
    public Member join(KakaoLoginResponseDto kakaoLoginResponseDto) {
        // UUID 생성
        UUID id = generateUUID();
        String nickname = "회원가입한 곰돌이";
        // 닉네임 랜덤 생성 및 중복 검사 메서드 추후 작성 필요

        // 성별 제공에 동의했는지 확인 하고 성별에 맞는 enum타입으로 변환
        Gender gender = Gender.MALE;
        if (kakaoLoginResponseDto.getKakao_account().getGender() == null)
            gender = Gender.NULL;
        else if (kakaoLoginResponseDto.getKakao_account().getGender().equals("female"))
            gender = Gender.FEMALE;

        // 회원가입한 사용자 정보
        Member member = Member.builder()
                .id(id)
                .channelId(kakaoLoginResponseDto.getId())
                .nickname(nickname)
                .email(kakaoLoginResponseDto.getKakao_account().getEmail())
                .gender(gender).build();

        // DB에 회원가입한 사용자 정보 저장
        memberRepository.save(member);
        return member;
    }

    // 사용자 이름 수정
    @Transactional
    public Member updateMemberName(MemberUpdateRequestDto memberUpdateRequestDto) {
        Member member = getMemberInfoWithId(memberUpdateRequestDto.getMember().getId());
        member.setName(memberUpdateRequestDto.getMember().getName());
        return member;
    }

    // channelId 기준으로 회원 정보 조회
    public Member getMemberInfoWithChannelId(String channelId) {
        try {
            return memberRepository.findByChannelId(channelId).get();
        } catch (NoSuchElementException e) {
            throw new NoSuchElementException("Cannot find member by channelId");
        }
    }

    // id 기준으로 회원 정보 조회
    public Member getMemberInfoWithId(UUID id) {
        try {
            return memberRepository.findById(id).get();
        } catch (NoSuchElementException e) {
            throw new NoSuchElementException("Cannot find member by id");
        }
    }

    // 중복되지 않는 UUID 생성
    private UUID generateUUID() {
        UUID id = UUID.randomUUID();
        while (checkUuidDuplicate(id)) {
            id = UUID.randomUUID();
        }
        return id;
    }

    // UUID 기준으로 중복 회원 확인
    private boolean checkUuidDuplicate(UUID id) {
        try {
            Member member = memberRepository.findById(id).get();
        } catch (NoSuchElementException e) {
            return false;
        }
        return true;
    }
}
```

### com.ssafy.member.controller.MemberController

```java
package com.ssafy.member.controller;

import com.ssafy.global.common.response.BaseResponse;
import com.ssafy.global.common.response.ResponseService;
import com.ssafy.member.dto.KakaoTokenResponseDto;
import com.ssafy.member.dto.MemberUpdateRequestDto;
import com.ssafy.member.dto.KakaoLoginResponseDto;
import com.ssafy.member.dto.MemberLoginResponseDto;
import com.ssafy.member.service.MemberService;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import java.util.NoSuchElementException;

@RestController
@RequiredArgsConstructor
@RequestMapping("/member")
public class MemberController {

    private final ResponseService responseService;
    private final MemberService memberService;

    // 카카오 로그인 요청 처리
    @GetMapping("/login")
    public BaseResponse<Object> loginCallBack(HttpServletRequest request) {
        // 인가코드로 토큰 발급
        KakaoTokenResponseDto kakaoToken = memberService.getKaKaoToken(request.getParameter("code"));
        // 토큰으로 카카오 사용자 정보 요청 (channelId, email, gender)
        KakaoLoginResponseDto kakaoLoginResponseDto = memberService.getMemberInfoWithToken(kakaoToken);

        // 사용자 channelId로 회원가입 여부 확인
        try {
            MemberLoginResponseDto loginMember = new MemberLoginResponseDto(memberService.getMemberInfoWithChannelId(kakaoLoginResponseDto.getId()));

            System.out.println(loginMember.toString());
            return responseService.getSuccessResponse("로그인 성공", loginMember);
        } catch (NoSuchElementException e) {
            MemberLoginResponseDto joinMember = new MemberLoginResponseDto(memberService.join(kakaoLoginResponseDto));
            return responseService.getSuccessResponse("회원가입 성공", joinMember);
        }
    }

    // 사용자 이름 수정 요청 처리
    @PostMapping("/update")
    public BaseResponse<Object> updateName(@RequestBody MemberUpdateRequestDto memberUpdateRequestDto) {
        return responseService.getSuccessResponse("이름 수정 성공", memberService.updateMemberName(memberUpdateRequestDto));
    }
}
```

### 카카오 로그인 결과

![Untitled.png](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%2021.png)

![Untitled (1).png](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled_(1).png)

### 채희찬

# Ec2

**SSAFY에서는 비싼 인스턴스 주기 때문에 넘어가도됨**

### Ec2 인스턴스 생성

Amazon Linux 2023 AMI → 아마존 리눅스

Ubuntu Server 22.04 LTS (HVM), SSD Volume Type → 우분투

![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%2022.png)

- 우측에 프리 티어 사용 가능 확인하기

![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%2023.png)

- 프리 티어는 메모리가 1GB이기 때문에 Swap Memory 고려할 것

![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%2024.png)

- 프리티어는 30GB까지 사용 가능

### Ec2 ssh 접속

```bash
sudo ssh -i pem키 기본이름@퍼블릭 DNS

// sudo ssh -i docker\ test.pem ubuntu@ec2-18-117-236-62.us-east-2.compute.amazonaws.com
```

---

# 도커

Ec2에 도커를 사용해 젠킨스 컨테이너를 띄울 예정

도커를 사용해 올리게 되면 젠킨스에 복잡한 설정을 안해도 됨

## **도커 공식 문서 - Install Docker Engine on Ubuntu**

[https://docs.docker.com/engine/install/ubuntu/](https://docs.docker.com/engine/install/ubuntu/)

### 도커 레포지토리 셋업

```bash
$ sudo apt-get update
$ sudo apt-get install \
    ca-certificates \
    curl \
    gnupg \
    lsb-release
```

### 도커의 공식 GPG 키 추가

```bash
$ sudo mkdir -p /etc/apt/keyrings
$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
```

### 레포지토리 셋업

```bash
$ echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
```

### 도커 엔진 설치

```bash
$ sudo apt-get update
$ sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin
```

### 도커 설치 확인

```bash
$ sudo docker run hello-world

Hello from Docker!
This message shows that your installation appears to be working correctly.
...
```

### 도커에 현재 가동중인 컨테이너 확인 명령어

```bash
$ sudo docker ps

// CONTAINER ID   IMAGE                 COMMAND                  CREATED        STATUS        PORTS                                                  NAMES
// 91fb52b9c096   jenkins/jenkins:lts   "/usr/bin/tini -- /u…"   36 hours ago   Up 36 hours   0.0.0.0:8080->8080/tcp, :::8080->8080/tcp, 50000/tcp   jenkins
```

### 도커 전체 컨테이너 확인 명령어

```bash
$ sudo docker ps -a
```

### 컨테이너 재실행

```bash
$ sudo docker start {컨테이너 이름}
```

- sudo docker ps -a 에는 있는데 실행중이 아니라면 start할 것

---

# 젠킨스

## 젠킨스 설치

### 젠킨스 이미지 다운로드

```bash
$ docker pull jenkins/jenkins:lts
```

### 젠킨스 컨테이너 띄우기

```bash
$ sudo docker run -d -p 8080:8080 -v /jenkins:/var/jenkins_home --name jenkins -u root jenkins/jenkins:lts
```

- -v 뒤의 앞 부분은 현재 디렉토리, :뒤의 부분은 이미지 내부 디렉토리
- run **옵션**
    - **d** : 컨테이너를 **데몬**으로 띄웁니다.
    - **p 8080:8080** : 컨테이너 외부와 내부 포트를 **포워딩**합니다. 좌측이 호스트 포트, 우측이 컨테이너 포트입니다.
    - **v /jenkins:/var/jenkins_home** : 도커 컨테이너의 데이터는 **컨테이너가 종료되면 휘발**됩니다. 도커 컨테이너의 데이터를 보존하기 위한 여러 방법이 존재하는데, 그 중 한 방법이 **볼륨 마운트**입니다. 이 옵션을 사용하여 젠킨스 컨테이너의 **`/var/jenkins_home`** 이라는 디렉토리를 호스트의 **`/jenkins`** 와 마운트하고 데이터를 보존할 수 있습니다.
    - **-name jenkins** : 도커 컨테이너의 이름을 설정합니다.
    - **u root** : 컨테이너가 실행될 리눅스의 사용자 계정을 root 로 명시합니다.

### 젠킨스 접속 명령어

```bash
$ sudo docker exec -u root -it {컨테이너 NAMES} /bin/bash
```

- permission denied를 방지하기 위해 root로 접속 하는것을 권장

### 젠킨스 내에서 자바 버전 확인

```bash
$ java --version

// openjdk 11.0.19 2023-04-18
// OpenJDK Runtime Environment Temurin-11.0.19+7 (build 11.0.19+7)
// OpenJDK 64-Bit Server VM Temurin-11.0.19+7 (build 11.0.19+7, mixed mode)
```

- 기본적으로 자바 11이 설치되어있음
- 자바 11을 프로젝트 버전에 맞게 바꿔줘야함

- 젠킨스는 자바 11부터 지원하기 때문에 8로 내릴 수 없음

### 자바 17 설치

```bash
apt-get update

apt-get install openjdk-17-jdk -y
```

# 젠킨스 설정

### 젠킨스 접속

```java
퍼블릭 IPv4 주소:8080
```

### 젠킨스 비밀번호 확인

```bash
$ sudo docker logs jenkins
```

![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%2025.png)

![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%2026.png)

![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%2027.png)

### pipeline script

```bash
pipeline {
   agent any
   stages {
       stage('Github') {
           steps {
               git branch: 'main', url: 'https://github.com/Broomii/broomii-backend.git'
           }
       }
       stage('Build') {
           steps {
               dir('./') {
                   sh '''
                   ./gradlew build
                   '''
               }
           }
       }
       stage('Deploy') {
           steps {
               dir('backend/build/libs') {
                   sshagent(credentials: ['credential']) {
                        sh 'scp demo-0.0.1-SNAPSHOT.jar ubuntu@18.117.236.62:/home/ubuntu'
                        sh 'ssh ubuntu@18.117.236.62 "sh run.sh" &'
                   }
               }
           }
       }
   }
}
```

### Build stage 에러시

```bash
dir('./'){
	sh'''
	pwd      // 현제 디렉토리 위치
	ls -l    // 권한 확인
	'''
}
```

- gradlew 있는 곳 까지 가야함

### 허태민

## 채팅

- 실시간 채팅 → webSocket
- SocketJS, STOMP

## 채팅방 입장 흐름

### 1. **매물 상세 페이지의 버튼을 통해 채팅방 입장**

```json
1. 버튼 클릭

2. 해당 매물 작성자(양도자)와 본인(양수자)의 채팅방 존재 여부 확인

3-1. 양도자와 양수자가 동일 인물이라면, 채팅방 목록으로 이동
3-2. 채팅방이 이미 존재한다면 바로 채팅방으로 이동
3-3. 채팅방이 존재하지 않다면 채팅방 생성 후 해당 채팅방으로 이동

4. 채팅방 입장시 이전 메시지 이력을 조회, 출력

5. 채팅 시작
```

### 2. **Navbar의 채팅 아이콘을 눌러 채팅방 입장**

```json
1. 아이콘 클릭

2. 내 채팅방 목록으로 이동

3. 채팅방 클릭

4. 채팅방 입장시 이전 메시지 이력을 조회, 출력

5. 채팅 시작
```

## 채팅 흐름

### SockJS

- websocket과 비슷한 기능을 제공하는 JS 라이브러리
- 브라우저와 웹 서버 사이에서 `짧은 지연 시간`, `크로스 브라우징을 지원`하는 API라는 것이 장점

### STOMP (Simple Text Oriented Messaging Protocol)

- pub/sub 기반으로 동작
- 이를 기반으로 메시지의 송/수신에 대해 명확하게 처리할 수 있음
- @MessageMapping 어노테이션을 사용
    - 메시지 발행 시 엔드포인트만 조정하여 쉽게 메시지 송/수신 가능

### Pub/Sub 개념

```json
채팅방 생성 : pub/sub 구현을 위한 Topic 생성
-> 즉 채팅방과 그에 맡는 주제 혹은 채팅방 명이라 생각

채팅방 입장 : Topic 구독(sub)
-> 해당 채팅방을 웹 소켓이 연결되어 있는 동안 구독
-> 구독의 개념은 해당 채팅방을 지속적으로 바라본다고 생각하면 좋음
-> 지속적으로 연결되고 바라보고 있기 때문에 새로운 송신(pub)이 되면 이를 수신(sub) 가능

채팅방 메시지 수신 : 해당 Topic으로 메시지 송신(pub)
-> 해당 채팅방으로 메시지를 송신(pub)
```

<aside>
🤔 내가 이해한 내용으로는

채팅방에 들어와 있는 모든 사람 (우리 서비스에서는 최대 나와 상대, 총 2명)은 현재 채팅방을 구독하고 있는 사람들이고

채팅을 보내면(pub) 채팅방 인원들은 수신(sub)

</aside>

![Untitled](%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A7%E1%86%BC%E1%84%80%E1%85%A1%20A804%20229a8dce873945b4905a47c203d85f04/Untitled%2028.png)

## 구현 코드 (미완)

### Build.gradle

```jsx
//STOMP 웹소캣 서버 사이드 테스트를 위한 의존성 추가
implementation("org.springframework.boot:spring-boot-starter-mustache")
implementation("org.springframework.boot:spring-boot-starter-websocket")

//STOMP 관련 프론트 라이브러리
// jQuery
implementation('org.webjars.bower:jquery:3.3.1')
// SockJS
implementation('org.webjars:sockjs-client:1.1.2')
// STROMP
implementation('org.webjars:stomp-websocket:2.3.3-1')
implementation('org.webjars:webjars-locator:0.30')
```

위 dependencies를 추가

**Configuration**

```java
@Configuration
@EnableWebSocketMessageBroker
public class SpringConfig implements WebSocketMessageBrokerConfigurer {
    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        // stomp 접속 주소 url => /ws-stomp
        registry.addEndpoint("/ws-stomp") // 연결될 엔드포인트
                .withSockJS(); // SocketJS를 연결한다는 설정
    }
    
    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        // 메시지를 구독하는 요청 url => 즉 메시지 받을 때
        registry.enableSimpleBroker("/sub");
        
        // 메시지를 발행하는 요청 url => 즉 메시지 보낼 때
        registry.setApplicationDestinationPrefixes("/pub");
    }
}
```

### DTO

**ChatDTO**

```java
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class ChatDTO {
    // 메시지 타임 : 입장, 채팅
    // 메시지 타입에 따라서 동작하는 구조가 달라진다.
    // 입장과 퇴장 (Enter, Leave)의 경우 입장/퇴장 이벤트 처리가 실행되고,
    // TALK는 말 그대로 내용이 채팅방을 SUB하고 있는 모든 클라이언트에게 전달됨
    public enum MessageType {
        ENTER, TALK, LEAVE;
    }
    
    private MessageType type; // 메시지 타입
    private String roomId; // 방 번호
    private String sender; // 채팅을 보낸 사람
    private String message; // 메시지
    private String time; // 채팅 발송 시간
}
```

채팅 메시지의 정보를 담는 객체

**ChatRoom DTO**

```java
// STOMP를 통해 pub/sub를 사용하면 구독자 관리가 알아서 된다.
// 따라서 따로 세션 관리를 하는 코드를 작성할 필요도 없고,
// 메시지를 다른 세션의 클라이언트에게 발송하는 것도 구현할 필요 X
@Data
@Entity
public class ChatRoom {
    @Id
    @Column(name = "room_id")
    private String id; // 채팅방 아이디
 
    private String grantorId; // 양도자 아이디

    private String assigneeId; // 양수자 아이디

    private Integer roomDealId; // 매물글 아이디

    public ChatRoom create(ChatCreateRequestDto chatCreateRequestDto) {
        ChatRoom chatRoom = new ChatRoom();
        chatRoom.id = UUID.randomUUID().toString();
        chatRoom.assigneeId = chatCreateRequestDto.getAssigneeId();
        chatRoom.roomDealId = roomDealId;

        return chatRoom;
    }
}
```

채팅방의 정보를 담는 객체

### Repository

```java
@Repository
public interface ChatRoomRepository  extends JpaRepository<ChatRoom, String> {
    // 채팅 목록 조회
    List<ChatRoom> findByAssigneeIdOrGrantorId(String assigneeId, String grantorId);

    // 채팅방 존재 여부 확인
    Optional<ChatRoom> findByAssigneeIdAndGrantorId(String assigneeId, String grantorId);
}
```

### Service

```java
@Service
@Slf4j
@RequiredArgsConstructor
public class ChatService {

    private final ChatRoomRepository chatRoomRepository;

    // roomID 기준으로 채팅방 찾기
    public ChatRoom findRoomById(String roomId) {
        return chatRoomRepository.findById(roomId).get();
    }

    public String createChatRoom(ChatCreateRequestDto chatCreateRequestDto) {
        ChatRoom chatRoom = new ChatRoom().create(chatCreateRequestDto);

        // 입력으로 들어온 양도자와 양수자의 id로 채팅방이 존재하는지 조회
        // 이전에 생성한 채팅방이 있지만 매물 상세보기 페이지에서 양도자와 채팅 버튼을 누른 경우
        ChatRoom dup = chatRoomRepository.findByAssigneeIdAndGrantorId(chatCreateRequestDto.getAssigneeId(), chatCreateRequestDto.getGrantorId()).get();

        if(dup != null) return dup.getId();

        chatRoomRepository.save(chatRoom);
        return chatRoom.getId();
    }
}
```

### DTO - API Request/Response용 DTO

**ChatCreateRequestDto**

```jsx
@Data
@NoArgsConstructor
public class ChatCreateRequestDto {
    @NotNull
    private String assigneeId;

    @NotNull
    private String grantorId;

    @NotNull
    private Integer roomDealId;
}
```

**ChatCreateResponseDto**

```jsx
@Data
@NoArgsConstructor
public class ChatCreateResponseDto {

    @NotNull
    private String roomId;
}
```

**ChatEnterRequestDto**

```jsx
@Data
@NoArgsConstructor
public class ChatEnterRequestDto {

    @NotNull
    private String roomId;

    @NotNull
    private String userId;
}
```

**ChatSendRequestDto**

```jsx
@Data
@NoArgsConstructor
public class ChatSendRequestDto {

    @NotNull
    private ChatDTO chat;
}
```

### Controller

**ChatRoomController**

```java
@RestController
@Slf4j
public class ChatRoomController {
    // ChatService Bean 가져오기
    @Autowired
    private ChatService chatService;

    @Autowired
    private ResponseService responseService;

    // 채팅방 생성
    // 채팅을 보내면 상대를 채팅방으로 초대
    // 메시지 보내기 -> 방 생성 -> 방으로 이동
    // 초대를 수락하면 -> 방 이동
    @PostMapping("/chat/createroom")
    public BaseResponse<?> createRoom(@RequestBody ChatCreateRequestDto chatCreateRequestDto) {
        // 방 생성
        String roomId = chatService.createChatRoom(chatCreateRequestDto);
        log.info("Create chat roomID {}", roomId);

        ChatCreateResponseDto response = new ChatCreateResponseDto();
        response.setRoomId(roomId);

        return responseService.getSuccessResponse("create success", response);
    }

    // 채팅방 입장 화면
    // 재입장시 과거 메세지 가져오기?
    // NoSQL 적용하면 그때 만들자
}
```

**ChatController**

```java
@Slf4j
@RequiredArgsConstructor
@Controller
public class ChatController {
    private final SimpMessageSendingOperations template;

    @Autowired
    ChatService service;

    // MessageMapping을 통해 webSocket으로 들어오는 메시지를 발신 처리한다.
    // 이때 클라이언트에서는 /pub/chat/message로 요청하게 되고 이것을 controller가 받아서 처리한다.
    // 처리가 완료되면 /sub/chat/room/roomId로 메시지가 전송된다.
    // userId, roomId,
    @MessageMapping("/chat/enterUser")
    public void enterUser(@Payload ChatEnterRequestDto chatEnterRequestDto, SimpMessageHeaderAccessor headerAccessor) {

        // 반환 결과를 socket session에 userUUID로 저장
        headerAccessor.getSessionAttributes().put("userID", chatEnterRequestDto.getUserId());
        headerAccessor.getSessionAttributes().put("roomId", chatEnterRequestDto.getRoomId());
    }

    @MessageMapping("/chat/sendMessage")
    public void sendMessage(@Payload ChatSendRequestDto chatSendRequestDto) {
        ChatDTO chat = chatSendRequestDto.getChat();
        log.info("CHAT {}", chat);
        
        // 전송 시간 설정
        Date date = new Date();
        SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        chat.setTime(formatter.format(date));

        template.convertAndSend("/sub/chat/room/" + chat.getRoomId(), chat);
    }

    // 유저 퇴장 시에는 EventListener를 통해 유저 퇴장을 확인
    @EventListener
    public void webSocketDisconnectListener(SessionDisconnectEvent event) {
        log.info("DisConnEvent {}", event);

        StompHeaderAccessor headerAccessor = StompHeaderAccessor.wrap(event.getMessage());

        // stomp 세션에 있던 uuid와 roomId를 확인해서 채팅방 유저 리스트와 room에서 해당 유저를 삭제
        String userUUID = (String) headerAccessor.getSessionAttributes().get("userUUID");
        String roomId = (String) headerAccessor.getSessionAttributes().get("roomId");

        log.info("headAccessor {}", headerAccessor);
    }
}
```

### Socket.js

```jsx
'use strict';

// document.write("<script src='jquery-3.6.1.js'></script>")
document.write("<script\n" +
    "  src=\"https://code.jquery.com/jquery-3.6.1.min.js\"\n" +
    "  integrity=\"sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ=\"\n" +
    "  crossorigin=\"anonymous\"></script>")

var usernameForm = document.querySelector('#usernameForm');
var messageForm = document.querySelector('#messageForm');
var messageInput = document.querySelector('#message');
var messageArea = document.querySelector('#messageArea');
var connectingElement = document.querySelector('.connecting');

var stompClient = null;
var username = null;

var colors = [
    '#2196F3', '#32c787', '#00BCD4', '#ff5652',
    '#ffc107', '#ff85af', '#FF9800', '#39bbb0'
];

// roomId 파라미터 가져오기
const url = new URL(location.href).searchParams;
const roomId = url.get('roomId');

function connect(event) {
    username = document.querySelector('#name').value.trim();

    // 연결하고자하는 Socket 의 endPoint
    var socket = new SockJS('/ws-stomp');
    
    stompClient = Stomp.over(socket);
    
    // {}는 header에 담길 내용, 뒤의 함수들은 콜백 함수
    stompClient.connect({}, onConnected, onError);

    event.preventDefault();
}

function onConnected() {
    // sub 할 url => /sub/chat/room/roomId 로 구독한다
    stompClient.subscribe('/sub/chat/room/' + roomId, onMessageReceived);
}

function onError(error) {
    connectingElement.textContent = 'Could not connect to WebSocket server. Please refresh this page to try again!';
    connectingElement.style.color = 'red';
}

// 메시지 전송때는 JSON 형식을 메시지를 전달한다.
function sendMessage(event) {
    var messageContent = messageInput.value.trim();

    if (messageContent && stompClient) {
        var chatMessage = {
            "roomId": roomId,
            sender: username,
            message: messageInput.value,
            type: 'TALK'
        };

        stompClient.send("/pub/chat/sendMessage", {}, JSON.stringify(chatMessage));
        messageInput.value = '';
    }
    event.preventDefault();
}

// 메시지를 받을 때도 마찬가지로 JSON 타입으로 받으며,
// 넘어온 JSON 형식의 메시지를 parse 해서 사용한다.
function onMessageReceived(payload) {
    var chat = JSON.parse(payload.body);

    var messageElement = document.createElement('li');
    messageElement.classList.add('chat-message');

    var avatarElement = document.createElement('i');
    var avatarText = document.createTextNode(chat.sender[0]);
    avatarElement.appendChild(avatarText);
    avatarElement.style['background-color'] = getAvatarColor(chat.sender);

    messageElement.appendChild(avatarElement);

    var usernameElement = document.createElement('span');
    var usernameText = document.createTextNode(chat.sender);
    usernameElement.appendChild(usernameText);
    messageElement.appendChild(usernameElement);

    var textElement = document.createElement('p');
    var messageText = document.createTextNode(chat.message);
    textElement.appendChild(messageText);

    messageElement.appendChild(textElement);

    messageArea.appendChild(messageElement);
    messageArea.scrollTop = messageArea.scrollHeight;
}

function getAvatarColor(messageSender) {
    var hash = 0;
    for (var i = 0; i < messageSender.length; i++) {
        hash = 31 * hash + messageSender.charCodeAt(i);
    }

    var index = Math.abs(hash % colors.length);
    return colors[index];
}

usernameForm.addEventListener('submit', connect, true)
messageForm.addEventListener('submit', sendMessage, true)
```

블로그를 참고하며 작성한 Socket.js 코드
